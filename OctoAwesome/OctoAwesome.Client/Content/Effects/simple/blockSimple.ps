uniform vec4 AmbientColor;
uniform vec4 DiffuseColor;
uniform vec3 DiffuseDirection;

uniform sampler2DArray BlockTextures;
uniform sampler2D ShadowMap;
uniform int ShadowEnabled;


in vec3 psNormal;
in vec2 psTexcoord;
flat in uint psTexIndex;

in vec4 shadowPosition;

out vec4 outColor;

vec2 poissonDisk[16] = vec2[]( 
   vec2( -0.94201624, -0.39906216 ), 
   vec2( 0.94558609, -0.76890725 ), 
   vec2( -0.094184101, -0.92938870 ), 
   vec2( 0.34495938, 0.29387760 ), 
   vec2( -0.91588581, 0.45771432 ), 
   vec2( -0.81544232, -0.87912464 ), 
   vec2( -0.38277543, 0.27676845 ), 
   vec2( 0.97484398, 0.75648379 ), 
   vec2( 0.44323325, -0.97511554 ), 
   vec2( 0.53742981, -0.47373420 ), 
   vec2( -0.26496911, -0.41893023 ), 
   vec2( 0.79197514, 0.19090188 ), 
   vec2( -0.24188840, 0.99706507 ), 
   vec2( -0.81409955, 0.91437590 ), 
   vec2( 0.19984126, 0.78641367 ), 
   vec2( 0.14383161, -0.14100790 ) 
);

// Returns a random number based on a vec3 and an int.
float random(vec3 seed, int i){
	vec4 seed4 = vec4(seed,i);
	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
	return fract(sin(dot_product) * 43758.5453);
}
void main()
{
    float DiffuseIntensity = clamp(-DiffuseDirection.z * 0.6,0.0,1.0);
    float AmbientIntensity = 0.2f + clamp(-DiffuseDirection.z *0.5f,0.0,0.8);
    float lighted = 1.0f;
    float cosTheta = clamp(dot(psNormal,DiffuseDirection),0,1);
    
    if(ShadowEnabled> 0)
    {
        float bias = 0.00002*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
        bias = clamp(bias, 0.00002,0.0001);
    
        float shadowZ = texture( ShadowMap,  shadowPosition.xy).z;
    
        if (shadowPosition.x >-1 && shadowPosition.x <1 &&  
            shadowPosition.y > -1 && shadowPosition.y <1 &&
             shadowZ <  (shadowPosition.z - bias)){
            float nightOpacity = clamp(DiffuseDirection.z+0.3,0.0,1.0);
            lighted = DiffuseIntensity + nightOpacity;
            for (int i=0;i<4;i++){
                int index = int(16.0*random(gl_FragCoord.xyy, i))%16;
                if (texture( ShadowMap, shadowPosition.xy + poissonDisk[index]/700.0).z < (shadowPosition.z - bias))
                  lighted -= 0.2;
            }
            lighted = clamp(lighted,0.0,1.0);
        }
    }

	vec4 texColor = texture(BlockTextures,vec3(psTexcoord,psTexIndex));
	vec4 ambient = AmbientColor * AmbientIntensity;
	vec4 diffuse = lighted*clamp(dot(-DiffuseDirection,psNormal),0.0,1.0) * DiffuseColor * DiffuseIntensity;
	outColor = texColor * clamp(ambient + vec4(diffuse.rgb,1.0),0.0,1.0);
}
