#version 130

#define COLOR_CASCADES 0

uniform float AmbientIntensity;
uniform vec4 AmbientColor;
uniform float DiffuseIntensity;
uniform vec4 DiffuseColor;
uniform vec3 DiffuseDirection;
uniform sampler2DArrayShadow ShadowMaps;
uniform sampler2D Texture;


#ifndef CASCADES
#define CASCADES 2
#endif

uniform mat4 CropMatrices[CASCADES];
uniform float CascadeDepth[CASCADES];

uniform mat4 View;

in vec3 psNormal;
in vec2 psTextureCoord;
in vec4 psFragWorldSpace;

out vec4 outColor;
float random(vec4 seed)
{
	float dotProduct = dot(seed, vec4(12.9898,78.233,45.164,94.673));
	return fract(sin(dotProduct) * 43758.5453);
}
float sampleShadow(vec4 psShadowCoord, float cosTheta, int layer)
{
	vec2 poissonDisk[4] = vec2[](
      vec2( -0.94201624, -0.39906216 ),
      vec2( 0.94558609, -0.76890725 ),
      vec2( -0.094184101, -0.92938870 ),
      vec2( 0.34495938, 0.29387760 )
    );
    
    float dir = dot(psNormal, -DiffuseDirection);
    if (dir < 0)
        return 0.0;
	
	//float bias = clamp(0.0005*tan(acos(cosTheta)), 0, 0.000005);
	float bias = max(0.05 * (1.0 - dir), 0.005);
    bias = 0.00;
	float visibility = texture(ShadowMaps, vec4(psShadowCoord.xy / psShadowCoord.w, layer, (psShadowCoord.z - bias) / psShadowCoord.w));
	return visibility;
}

void main()
{
	vec4 texColor = texture(Texture, psTextureCoord);
	vec4 ambient = AmbientColor * AmbientIntensity;
	float cosTheta = clamp(dot(-DiffuseDirection,psNormal),0.0,1.0);
	vec4 diffuse = cosTheta * DiffuseColor * DiffuseIntensity;
	vec4 fragPosViewSpace = View * vec4(psFragWorldSpace.xyz, 1.0);
	float depthValue = abs(fragPosViewSpace.z);
	
	
    int layer = -1;
    for (int i = 0; i < CASCADES; ++i)
    {
        if (depthValue < CascadeDepth[i])
        {
            layer = i;
            break;
        }
    }
    if (layer == -1)
    {
        outColor = texColor;
        return;
    }
    
    
    vec3 cascade_colors[2] = vec3[](
        vec3(1.0, 0.0, 0.0),
        vec3(0.0, 0.0, 1.0)
    );
    
	
	vec4 psShadowCoord = CropMatrices[layer] * psFragWorldSpace;
	psShadowCoord = psShadowCoord * 0.5 + 0.5; // bias
	float visibility = sampleShadow(psShadowCoord, cosTheta, layer);
#if COLOR_CASCADES
    ambient = (ambient + vec4(cascade_colors[layer], 1.0)) / 2.0;
#endif
	outColor = texColor * clamp(ambient + vec4(diffuse.rgb * visibility,1.0),0.0,1.0);
}
