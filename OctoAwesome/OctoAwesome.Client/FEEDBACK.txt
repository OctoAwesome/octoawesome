Ralf per Codeplex (13.03.)
==========================
- Bitte dreifach-Operationen vereinfachen (also bei der ganzen Achsen-Trennung)

Lassi per Codeplex (17.03.)
===========================
2) Noch ein Fehler bei der Berechnung
   "powerdirection += ExternalForce;" müsste "powerdirection += externalpower;" sein

Andy via Email (07.04.)
=======================
- Game States (Loading, Playing, Saving) einführen
- Nur Chunks speichern, die einen Dirty-Flag haben -> ChangeCounter

Nachtrag von Ralf per Email (16.04.)
====================================
Umbau von Flush im Cache -> nicht leeren. So könnte man, wenn die "nur speichern wenn verändert"-Prüfung drin ist, regelmäßig Dumps auf die Platte speichern und minimiert dadurch den Speicherprozess am Ende des Spiels.
Begrifflichkeiten im Cache irreführend. Sinnvolle wären die typischen Werte get(), put(), replace(), remove(), putIfAbsent()

RedworkDE via YouTube (11.04.)
==============================
- Chunk Serializer optimierung -> Wenn BlockTypes.Count == 0 -> alles luft - abbrechen
- Bug in L2 wenn man aus dem Level fällt

Andy via Email (10.04.)
=======================
- Liste "ActiveChunkRenderer" ist inzwischen unnötig
- InUse kann auf chunk!=null gemappt werden
- ChunkRenderer erst erzeugen, wenn gebraucht wird
- Streuung im Index3-Hash? -> Dictionary O(1)

Ralf per Email (13.04.)
=======================
- Cache Load-Issue im Cache (siehe Eintrag von Tom weiter unten)

Tom (14.04.)
============
- Cache Getter gibt immernoch default(V) zurück, selbst wenn ein neues Element generiert wurde -> Am Anfang alles leer
- Zugriffe auf die Festplatten- und Generatorzugriffe überschlagen sich (Cache) - vielleicht doch lock
- Code Optimierung in SceneComponent (Zeile 290): Es gibt NormalizeXY mit Index3 als Parameter
- Nebel im Chunk-Renderer einfügen!
    effect.FogEnabled = true;
    effect.FogColor = Color.CornflowerBlue.ToVector3();
    effect.FogStart = SceneComponent.VIEWRANGE * OctoAwesome.Chunk.CHUNKSIZE_X * 0.3f;
    effect.FogEnd = SceneComponent.VIEWRANGE * OctoAwesome.Chunk.CHUNKSIZE_X * 1.0f;
- Speicherüberlauf in der Grafikkarte -> Absturz des GraKa-Treibers
  * Speicher-Profiling in der GraKa
  * VB und IB-Recycling?
- Cache wieder synchronisieren mit ReaderWriterLockSlim

Andy via Email (14.04.)
=======================
- Chunkrenderer-Limit nach oben destinationChunk.Z = Math.Max(0, Math.Min(planet.Size.Z, destinationChunk.Z)); nicht so clever. ViewRange nach oben sollte berücksichtigt werden.
- Bug: Keine Maussteuerung möglich bei WASD-Steuerung? (kann ich leider nicht nachvollziehen)
- Recycling für die Cache-Objekte
- Performancen-Frage bei OrderBy im Cache (ermittlung des ältesten Elements) -> Alternative eine verkettete Liste als Queue
- Performance-Frage bei Ermittlung des ElapsedMilliseconds der StopWatch. int++ schneller

Ralf via Email (15.04.)
=======================
- Performance Profiler ist Teil der Community Edition 2013 - hurra
- Hashtable kein Baum. Schlechte Hash-Methode. Addition zu viele Kollisionen. Besser (Hash = (((Z * dimY) + Y )* dimZ + Z) % prim; mit prim nahe maxInt (ideal (2^n)-1, dann kann man bitweise-& statt %)
- Ausgabe auf die Console nicht wirklich cool. Einbindung von log4net
- evtl. Caching-Framework (ehcache.org)

Andy via Email (16.04.)
=======================
- Hash-Generierung doof :) und kein Baum
- Alternativ tryAdd bei ConcurrentDictionary?
- 2-Level Cache hat ein Problem: L1 könnte Elemente halten die von L2 schon entfernt wurden
- Cache zurück zum Lock
- Fenstergröße bitte änderbar

Cleanup
=======
- Texture (Mehrteilig)
- Friction (Auf Block-Instanz)
- Angle-Klasse
- Chunkgröße auf 16 runter? Oder dynamisch machen
- ExtensionLoader
- InstanceManager fur Universe, Planet, 
- Persistierung von Chunks bereits beim Erzeugen
- -> SimpleNoiseGenerator, line 162, serialisieren
- Smartere Priorisierung der ChunkRenderer (Neusortierung nach jedem Chunk, dann fällt auch die Highprio-Liste raus)
